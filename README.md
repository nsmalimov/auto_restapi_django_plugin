### Как использовать:

1. Скопировать текущий код в django-проект. Например создать папку "plugins" внутри проекта и скопировать в неё.
Можно взять тестовый проект на django: https://github.com/nsmalimov/django_test_auto_restapi. Внутрь него уже скопирован данный плагин.
2. Создать app в джанго-проекте.
3. Описать модели в файле models.py
4. В файле settings.py добавить этот плагин в INSTALLED_APPS:
    ```
    INSTALLED_APPS = [
    ...
    'plugins.auto_restapi_django_plugin'
    ...
    ]
    ```
5. Убедиться, что в папке views и в папке urls отсутствуют файлы __init__.py, так как
плагин в этом случае не сможет создать свои. Если есть необходимость сохранить свои __init__-файлы, то
необходимо скопировать их код, удалить существующие __init__ файлы и после запуска плагина вставить свой код в 
новые созданные файлы. Также необходимо убедиться, что отсутствуют в папке файлы внутри папок 
views и urls таких как имя_модели_view.py и имя_модели_url.py или же провести с ними 
аналогичную процедуру.
6. Запустить плагин: `python manage.py create_restapi app_name`
Где app_name - название приложения для которого необходимо создать RESTApi.
7. После чего буду созданы views-файлы в папке views и urls в папке urls.
8. Запустить django-приложение: `python manage.py runserver`

### Описание RESTApi (которое будет сгененировано):
1. GET
    * http://localhost:8000/person - получение всех объектов
    * http://localhost:8000/person/1 - получение объекта по id=1
    
    Фильтрация:
    Только для массового получения объектов (без id)
    * По полям (http://localhost:8000/person?name=Пётр). Подддерживается множественный селект по нескольким полям (name=Пётр&city_id=2).
    * Сортировка (http://localhost:8000/person?sord_by=+name). Подддерживается также мультисортировка (sort_by=+name,-city_id).
    * Лимиты (http://localhost:8000/person?limit=100)
    
    Все фильтры можно комбинировать.
    
    Написаны валидаторы и обработка ошибок и не валидных данных.

2. POST
    ```
    curl --header "Content-Type: application/json" \
      --request POST \
      --data '{"name": "Moscow", "population": 15000000}' \
      http://localhost:8000/city
    ```
3. PUT
    ```
    curl --header "Content-Type: application/json" \
      --request PUT \
      --data '{"name": "Moscow", "population": 16000000}' \
      http://localhost:8000/city/1
    ```
4. DELETE
    ```
    curl \
      --request DELETE \
      http://localhost:8000/city/1
    ```
   
###  Устройство:
При написании вдохновлялся кодом либы: https://github.com/krisfields/django-baker/stargazers

### Что можно улучшить:
1. В данный момент не работает через pip, для этого необходимо создать setup.py и файл манифеста.
2. Написать тесты:

    Тестировал при разработке через Postman, вызывая ручки API руками. Внутри тестового проекта на django написал свои модели.
    Создал через миграции таблицы в базе. Через фикстуры заполнил тестовыми данными и проверил каждую ручку на корректность возвращаемого
    значения.
    
    Думал насчёт тестов из питона, но не хватило времени на полноценно написанные тесты.
    
    Но надо подумать как тестировать, в идеале даже можно и 2 сразу концепции применить.
    
    * Первый путь, когда тестируется через сам плагин. То есть мы подаём флаг при вызове плагина, что-то вроде
    `python manage.py create_restapi test [Person:1,City:1,JobInfo:2]`
    
        И он внутри себя прогоняет тесты с реальными запросами на запущенное django-приложение.
        
        Person:1 - это мы указываем id-объекта для получения его по GET-запросу и провеи на то, что объект был получен
        и что ручка работает.
    
    * Также можно написать внутренние тесты для плагина, которые проверят его работу через unit-тесты. Также
        можно искусствено вызвать генерацию на классах (имитация работы через manage.py).

3. Автоматическое подключение swagger-а.
4. Есть кейс, когда модели могут лежать в отдельной папке типа "models".
Можно научить брать оттуда.
https://stackoverflow.com/questions/5534206/how-do-i-separate-my-models-out-in-django
Также по аналогии с url.
5. Авторизация. Проверить как API будет работать с авторизацией. Могут быть дополнительные правки для поддержки авторизации (CsrfViewMiddleware).
6. Подумать как можно сделать с https://www.django-rest-framework.org/. Вставив в settings.py как зависимость и используя уже готовые компоненты.
7. Усилить валидацию (проверка на лишние параметры, проверка, что присутствуют только поля, допустимые для модели). Я много
времени уделил валидации входящих в api параметров. Но всё равно есть кейсы, такие как
например передача "лишних" параметров или лишних полей объекта или лимит < 1.
8. Усилить проверку на ошибки, обернуть в try catch с детальным описанием ошибки и кодом ответа.
9. Отрефакторить, разнеся на отдельные функции внутри views.
10. Ощущение, что при генерации url-файлов можно сделать изящнее.